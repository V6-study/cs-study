## 시스템 콜(System Call)

![image](https://github.com/user-attachments/assets/de8d3e10-1d41-4408-a2c7-ccbad851fe8c)

운영체제는 사용자 모드(User mode)와 커널 모드(Kernel mode)로 나뉘어 동작한다. 이를 이중 동작 모드(Dual Mode Operation)라고 한다.

사용자 모드는 하드웨어에 직접적으로 접근할 수 없고, 커널 모드는 모든 시스템 메모리와 CPU Instruction 뿐만 아니라 하드웨어에도 직접 접근이 가능하다.

이렇게 이중 동작 모드로 사용자가 하드웨어와 직접적으로 상호작용 하는 것을 막아 시스템을 보호한다. 대신, 사용자는 시스템 콜(System Call)을 통해 커널모드로 접근할 수 있다.

<br/><br/>
**※ 시스템콜** :

-   운영체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스  
    \[유저\] --> \[시스템콜\] --> \[커널 함수\]
    
-   프로세스 관리, 파일관리, 디바이스 관리, 정보 유지(시간 및 날짜 관련 시스템), 프로세스 간 통신 때 사용


**※ 커널** :

-   운영체제의 핵심 부분이자 시스템콜을 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역할

<br/><br/><br/><br/>
---
## 시스템 콜 처리 과정

ex) 파일 open 과정

![image](https://github.com/user-attachments/assets/01705d4e-e0ce-4462-8bb4-f66e03aec83a)


1.  유저 애플리케이션이 파일을 열기 위한 함수(open)를 호출.

2.  시스템 콜 인터페이스를 통해 커널 모드로 전환. 이때 시스템 콜 번호 할당과 적절한 핸들러를 정의가 이루어짐.

3.  커널은 시스템 콜 번호에 따라 적절한 핸들러를 호출.

4.  커널 함수(sys\_open)를 호출하여 실제 파일 시스템과 상호작용하면서, 파일을 열고 파일 디스크립터를 생성

5.  시커널은 파일 디스크립터를 유저 애플리케이션에 반환.

6.  유저 애플리케이션은 반환된 파일 디스크립터를 사용하여 파일 작업을 수행.


<br/>

### Java는 JNI(Java Native Interface)을 통해서 시스템 콜을 거친다!

-   \[C 애플리케이션\]  ->  \[시스템 콜\]  ->  \[커널\]
  
-   \[Java 애플리케이션\]  ->  \[JNI\]  ->  \[시스템 콜\]  ->  \[커널\]

Java는 JVM(Java Virtual Machine)위에서 실행되기 때문에 다양한 플랫폼에서 동일한 실행이 가능하다.

하지만 하드웨어나 운영체제에 의존적인 작업을 수행하려면 JNI을 이용해 네이티브 코드(C/C++)를 호출해야 한다.

C/C++은 낮은 수준의 언어로 운영체제와 직접적인 상호작용이 가능하여 시스템 콜을 쉽게 호출할 수 있다.

<br/><br/><br/><br/>
## modebit

시스템콜이 작동될 때 CPU는 modebit을 기반으로 유저 모드와 커널 모드를 구분.

modebit 은 1 또는 0의 값을 가지는 플래그 변수이며 1은 유저모드, 0은 커널모드.

-   시스템 부팅 시 기본적으로 modebit은 0(커널 모드)으로 시작됨.
  
-   애플리케이션이 실행되면 modebit은 1로 전환. 즉, 프로세서는 사용자 모드에서 실행.
  
-   시스템 콜이 발생하면 modebit은 0으로 변경하여 해당 요청을 처리.


<br/><br/><br/><br/>

참고

[\[velog\] system call이란?](https://velog.io/@yyeong/system-call%EC%9D%B4%EB%9E%80)
[\[tistory\] [\[운영체제\] 시스템 콜(System Call)](https://c4u-rdav.tistory.com/85)
