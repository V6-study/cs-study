### **단편화**

|   #### 내부단편화   |   #### 외부단편화   |
| --- | --- |
| 메모리 블록 안에 사용되지 않는 공간이 발생하는 현상. | 메모리 블록 밖에 사용 가능한 메모리 공간이 여러 조각으로 나뉘어, 필요한 만큼의 큰 연속된 메모리 블록을 확보하지 못하는 현상. |
|![image](https://github.com/user-attachments/assets/d661b8ca-d7e0-4cc8-bfea-164831ad54f2) | ![image](https://github.com/user-attachments/assets/1cad663b-e2a8-4ed1-a03b-3921dc243ee3)|

<br/><br/><br/>

프로그램에 필요한 메모리를 할당할 때 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하며, 연속할당과 불연속 할당으로 나뉜다.
<br/><br/><br/><br/><br/>

### **연속할당** **(contiguous memory allocation)**

하나의 연속된 메모리 블록에 프로세스를 할당하는 방식. 물리적으로 연속된 공간을 사용하는 메모리 관리 기법이다.
<br/><br/>

#### 고정 분할 (Fixed Partitioning)

-   메모리를 일정한 크기로 분할하여 프로세스를 할당하는 방식. 즉, 시스템이 시작될 때 고정된 크기의 파티션으로 나누고 이 크기가 변하지 않는다.
-   **내부 단편화**가 발생할 수 있다. 만약 할당된 파티션보다 프로세스 크기가 작다면 남는 메모리는 비어 있게 되어 효율이 떨어질 수 있다.
-   프로세스가 필요한 메모리보다 큰 파티션에 배치되거나, 프로세스 크기에 딱 맞는 파티션이 없다면 작업이 불가능해지는 경우가 있다.
-   **메모리 관리가 간단**하며, 오버헤드가 적고 할당 및 해제 속도가 빠르다.
<br/><br/>

#### 가변 분할 (Variable Partitioning)

-   고정된 파티션 없이 **필요한 만큼의 메모리를 할당**하는 방식. 프로세스의 크기에 맞춰 메모리 공간을 동적으로 나눈다.
-   **외부 단편화**가 발생할 수 있다. 여러 프로세스가 메모리에서 해제되면서 남은 공간이 흩어져 비어 있게 된다.
-   단편화를 해결하기 위해 압축(compaction)을 사용할 수 있다. 이는 흩어진 메모리 조각들을 하나로 모아 공간을 확보하는 방식.
-   메모리 관리에 더 복잡한 알고리즘이 필요하고, 할당 및 해제의 오버헤드가 발생할 수 있습니다.
-   메모리를 동적으로 사용하여 **메모리 사용 효율이 높다**는 장점이 있음

<br/><br/><br/><br/><br/>

### **불연속할당 (non-contiguous memory allocation)**

프로그램이 연속된 메모리 블록에 할당되지 않고, 여러 곳에 나누에 배치되는 방식. 
<br/><br/>

#### 페이징 (Paging)

![image](https://github.com/user-attachments/assets/f3733aaf-cec7-4eea-b7c6-d573fd4bfca9)


-   프로세스를 **일정한 크기인 페이지**로 나누고, 메모리도 **동일한 크기의 프레임**으로 나눈 후, **각 페이지를 프레임에 할당**하는 방식.
-   페이지 테이블을 사용하여 논리 주소의 페이지 번호를 물리 주소의 프레임 번호로 변환한다.  
    (논리 주소는 페이지 번호와 페이지 내부 오프로 구성)
-   페이지와 프레임의 크기가 같아 필요한 프레임에 페이지를 배치함으로써 **외부단편화를 방지**한다. 하지만 **내부단편화가 발생**할 수 있다
-   메모리 할당이 유연해지고 메모리 사용 효율이 높아진다.
-   프로세스가 할당받은 프레임이 여러곳에 흩어지면서 캐시 히트율이 낮아질 수 있다.
<br/><br/>

#### 세그멘테이션 (Segmentation)

![image](https://github.com/user-attachments/assets/86a19de1-f1e8-43ba-b2ec-571573201fb2)


-   프로세스를 **논리적으로 나눈 세그먼트**(코드, 데이터, 스택)들을 각각 **메모리의 다양한 위치에 할당**하는 방식.
-   세그먼트 테이블을 사용하여 각 세그먼트의 시작 주소와 크기를 기록해야 한다.  
    (논리 주소는 세그먼트 번호와 세그먼트 내 오프로 구성)
-   프로세스 논리적 구조를 반영하여 메모리 관리가 유연하고 효율적.
-   코드와 데이터가 논리적 단위로 구분되므로, 같은 세그먼트를 다른 프로세스에서 공유할 수 있다.
-   세그먼트 크기가 다양하기 때무넹 빈 공간이 여러조각으로 나뉘어 배치 효율이 떨어질 수 있다. 즉, **외부 단편화가 발생**할 수 있다.
-   세그먼트가 너무 작으면 할당/해제가 자주 이루어져 오버헤드가 커질 수 있다.
<br/><br/>

#### 페이지드 세그멘테이션(Paged Segmentation)

-   페이징과 세그멘테이션을 결합한 방식. **프로세스를 세그먼트로 나눈 후, 각 세그먼트를 다시 페이지로 나눠 관리**한다.
-   **세그먼트 테이블**과 각 세그먼트에 대한 **페이지 테이블**이 필요하다. → 메모리 관리가 복잡. 관리 오버헤드 증가
-   외부단편화를 방지하고 세그멘테이션의 논리적 구분을 유지할 수 있다.
-   메모리 사용 효율성과 프로세스의 구조적 가시성이 높아진다.
