### 가상 메모리(Virtual Memory)란?

가상메모리는 OS에서 사용되는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용가능한 메모리 자원(실제 주소, physical address)  
을 추상화 하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것이다.

<br/><br/>
**☑️ 가상 메모리의 장점**

**1\. 주기억장치의 효율적인 관리(스와핑)**

하드디스크를 주기억장치에 대한 캐시로 설정. 쓰지않는 영역은 하드디스크로 옮긴 뒤 필요할 때만 램에 데이터를 불러와 올리고 사용하지 않으면 하드디스크로 내림으로써 램을 효과적으로 관리.

**2\. 메모리 관리의 단순화**

각 프로세스마다 가상 메모리의 통일 된 주소 공간을 배정할 수 있으므로 메모리 관리가 단순해짐.

**3\. 메모리 용량 및 안정성 보장**

가상메모리 공간은 거의 무한하다고 생각해도 된다. 때문에 프로세스들끼리 메모리 침범이 일어날 여지를 줄이게 됨.

<br/><br/><br/><br/>
### 페이지테이블 (Page Table)

> **페이지테이블?** 가상 메모리 시스템에서 가장 주소를 실제 주소로 변환해주는 테이블  
> **페이지?** 가상메모리를 사용하는 최소 크기 단위  
> **프레임?** 실제 디스크나 메모리를 사용하는 최소 크기 단위

가상 메모리는 페이지 테이블에 의해 실제 주소로 변환된다.

즉, 페이지 번호와 프레임 번호를 짝지어 일종의 이정표 역할을 한다.

![image](https://github.com/user-attachments/assets/da43013c-1975-420d-8f08-1d80d97fdd65)

<br/><br/>
프로세스마다 각자 페이지 테이블을 가지고 있다.

CPU는 **PTBR (Page Table Base Register)**을 가지고 있고, PTBR은 각 페이지 테이블의 시작주소를 가리킨다.

![image](https://github.com/user-attachments/assets/5a593b64-73e2-4a40-96ea-bdc46a31dbe0)


<br/><br/><br/><br/>
### TLB(Translation Lookasid Buffer)

페이지 테이블은 메모리에 존재하는데, 이는 메모리 접근 시간이 두배로 늘어난다는 단점이 있다.

(페이지 테이블을 보기위해 한번, 실제 주소로 접근하기 위해 한번)

때문에, TLB를 사용하여 페이지 테이블 접근 시간을 단축시킨다.

> **TLB?** 페이지 테이블 항목을 캐시하는 고속 메모리  
> **캐시?** 동일한 데이터에 반복해서 접근해야 하거나 많은 연산이 필요한 일일때, 결과를 빠르게 이용하고자 성능이 좋은 혹은 가까운 곳에 저장하는 것

가상 주소에서 바로 페이지 테이블로 가지 않고 TLB를 확인하고, 만약 없다면 페이지 테이블로 가서 실제 주소를 가져온다.

<br/><br/><br/><br/>
### 페이지 테이블 엔트리(PTE, Page Table Entry)

페이지 테이블의 각각 행동들을 페이지 테이블 엔트리라고 한다.

1.  유효비트(valid bit) : 현재 해당 페이지에 접근 가능한지 여부.
2.  보호비트(protection bit) : 페이지에 접근할 권한을 제한하는 비트(rwx순으로 2bit으로).
3.  참조비트(reference bit) : CPU가 해당 페이지에 접근한 적이 있는지 여부.
4.  수정비트(modified bit) : 해당 페이지에 데이터가 수정된 적이 있는지 여부. 스왑 아웃 될 때 보조기억 장치에 기록하기 위해 사용.

<br/><br/><br/><br/>
### 페이지폴트 (Page fault)와 스와핑

> **스왑 영역(Swap Space)?** 프로세스의 가상 메모리 공간 전체를 위해 예약된 디스크 공간  
> **스와핑?** 메모리의 당장 사용하지 않는 영역을 하드 디시크로 옮기고 하드디스크의 일부부분을 "마치 메모리처럼" 불러와 쓰는 것  
> **MMU(Memory Management Unit)?** 컴퓨터 시스템에서 메모리 접근을 관리하고 가상 메모리와 물리적 메모리 간의 매핑을 처리하는 하드웨어 컴포넌트

가상 메모리는 작은 메모리를 매우 큰 메모리로 보이게 끔 하는 것. 때문에 가상메모리서 참조하려는 메모리 영역이 실제에는 없을 수도 있음.(접근 불가 -> 유효비트 0)
그럴 때 접근하려고 하면 **페이지 폴트** 예외가 발생한다. 이 경우 보통 **스와핑**이 일어나게 된다.
: 밀려난 애들은 디스크의 스왑 영역 또는 파일 시스템에서 페이지 위치 확인할 수 있다. (페이지 테이블 엔트리에는 페이지가 디스크의 어디에 저장되어 있는지에 대한 정보가 포함되어 있음.)


<br/><br/>
**페이지 폴트 과정**

![image](https://github.com/user-attachments/assets/84fd2bf1-87db-4890-bc0a-a22d76da6f85)


1.  invalid 페이지에 접근하면 MMU가 trap을 발생시켜 운영체제에게 알림
2.  운영체제는 CPU의 동작을 멈춤. CPU 내 기존 작업 내역 백업
3.  운영체제는 요구된 페이지를 가상메모리에서 찾음
4.  해당 페이지를 물리적 메모리에 비어있는 프레임에 로드
5.  페이지 테이블 최신화. 유효비트 1로 변경
6.  CPU 다시 시작

\-> 이제 CPU는 해당 페이지에 접근 가능!

<br/><br/><br/><br/>
### 스레싱(Thrashing)

스레싱은 페이지 폴트율이 높다는 것을 의미한다.

> 페이지 폴트 발생  
> ↓  
> CPU 이용률 낮아짐  
> ↓  
> 운영체제는 CPU가용성을 높이기 위해 더 많은 프로세스를 메모리에 올리게 됨

이런 악순환이 반복되며  메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생하게 된다.

<br/><br/>
**하드웨어적 해결 방법**

1\. 메모리 늘리기: 더 많은 RAM을 추가

2\. 빠른 디스크 사용 : HDD를 사용하고 있다면 SDD로 교체

3\. TLB 크기 증가

등등 ...

<br/><br/>
**소프트웨어적 해결 방법**

1.  워킹 셋 모델 (Working Set Model)  
    프로세스의 과거 사용 이력을 기반으로 많이 사용하는 페이지 집합을 만들어 한꺼번에 미리 메모리 로드 하는것.
2.  PFF(Page Fault Frequency) 기법  
    페이지 폴트가 발생하는 빈도를 모니터링하고 시스템의 메모리 관리 정책을 동적으로 조정. 상한선과 하한선을 정하고 상한선에 도달하면 프레임 늘리고 하한선에 도달하면 프레임을 줄이는 방식.
3.  페이지 교체 알고리즘 최적화  
    LRU(Least Recently Used), LFU(Least Frequently Used), FIFO(First In First Out) 등의 페이지 교체 알고리즘을 사용하여 페이지 교체 효율을 높임

등등 ...
<br/><br/><br/><br/>
참고

[운영체제 - 가상메모리, 페이징, 페이지 테이블, PTBR, TLB](https://code-piggy.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%8E%98%EC%9D%B4%EC%A7%95-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-PTBR-TLB#google_vignette)

[\[컴퓨터 구조\] 메모리\[6\] - 가상메모리(Virtual Memory)](https://ttl-blog.tistory.com/1097#%F0%9F%A7%90%20page%20table-1)

[\[OS\] 가상메모리와 페이지폴트](https://velog.io/@jiseong/OS-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B8-gyq8tftz)
