# 페이지교체 알고리즘

## LFD(Longest Forward Distance, 오프라인 알고리즘)

가장 먼 미래에 참조되는 페이지와 현재 페이지를 바꾸는 알고리즘

- 가장 좋은 알고리즘이지만 우리는 미래에 사용되는 프로세스를 알지 못하므로 사용할 수 없다. 다른 알고리즘과의 성능비교 기준으로 쓰인다.



## FIFO(First In First Out)

가장 먼저 온 페이지부터 교체하는 방법

- 페이지가 들어온 시간을 저장하거나 큐를 사용하여 순서를 관리한다.

장점

- 구현이 간단하다.
- 초기화 코드에 적합한 방식이다. (순차 실행, 반복 없음, 예측 가능성)

단점

- 자주 사용되는 페이지가 교체될 수 있다. (아래 예시 참고)

![img](https://github.com/user-attachments/assets/341833c6-3993-4cea-a6a2-41c4008ea688)

예를 들어 페이지 참조 순서가 1, 3, 0, 3, 5, 6, 3이라고 하면,

- 순서대로 1, 3, 0을 비어있는 프레임에 저장한다. (Miss)
- 두 번째 3 입력: 이미 메모리에 있으므로 변화가 없다. (Hit)
- 5 입력: 가장 오래된 페이지 1을 5로 교체한다. (Miss)
- 6 입력: 그 다음으로 오래된 페이지 3을 6으로 교체. (Miss)
- 3 입력: 0을 3으로 교체. (Miss)

총 6번의 페이지 폴트(Miss)가 발생한다. 3은 여러 번 참조되었지만, 마지막에 다시 로드되어야 했다. 



## LRU(Least Recently Used)

가장 오랫동안 사용되지 않은 페이지를 교체하는 방법

- 큐를 사용하여 구현할 수 있으며, 최근 사용된 페이지를 큐의 맨 위로 이동시킨다.
- 효율적이지만, 매 메모리 접근마다 시간을 기록해야 하므로 오버헤드가 큰 편이다.

![img](https://github.com/user-attachments/assets/97712e5e-07e2-4b35-be04-aec538a4814d)

예를 들어 페이지 참조 순서가 7, 0, 1, 2, 0, 3, 0, 4라고 하면,

- 메모리에 7, 0, 1, 2를 담는다.
- 0 참조: 0을 가장 최근 사용된 페이지로 올린다.
- 3 참조: 메모리에 없으므로, 가장 오래 사용되지 않은 페이지 7을 3으로 교체한다.
- 0 참조: 0을 가장 최근 사용된 페이지로 올린다.
- 4 참조: 메모리에 없으므로, 가장 오래 사용되지 않은 페이지 1을 4로 교체한다.

## NRU(Not Recently Used)

LRU에서 발전한 알고리즘으로, clock 알고리즘이라고도 부른다. 

적은 오버헤드로 적절한 성능을 제공한다. 실제 운영체제에서 자주 사용되는 편이다.

![img](https://github.com/user-attachments/assets/4ec747c1-ed94-4cdd-b197-98961de63cf0)

- 페이지들이 원형으로 배열되어 있다.
- 각 페이지마다 참조 비트(R)와 변형 비트(M)를 사용한다.
    - R 비트는 페이지 참조 시 1로 설정되고, 주기적으로 0으로 리셋된다.
    - M 비트는 페이지 내용이 변경될 때 1로 설정된다.
- 포인터: 빨간 화살표는 현재 검사 중인 페이지를 가르키는 포인터이다.
- 교체 우선순위: (R=0, M=0) → (R=0, M=1) → (R=1, M=0) → (R=1, M=1)
- 페이지 부재 발생 시, 포인터가 회전하며 교체할 페이지를 찾는다.
    - R=0인 페이지를 찾으면 그 페이지를 교체한다.
    - R=1인 페이지는 0으로 바꾸고 다음으로 넘어간다.
    - 교체할 페이지를 찾을 때까지 이 과정을 반복한다.



## LFU(Least Frequently Used)

참조 횟수가 가장 적은 페이지를 교체하는 방법

- 각 페이지의 참조 횟수를 카운트하여 관리한다.

장점

- 장기적인 사용 패턴을 반영할 수 있다.

단점

- 구현이 복잡하고 오버헤드가 큰 편이다.
- 최근에 불러온 페이지가 참조 횟수가 적어 교체될 수 있다.
- 초기에 자주 사용된 페이지가 나중에 사용되지 않아도 메모리에 오래 남을 수 있다.

![img](https://github.com/user-attachments/assets/f2213af7-c1eb-4bcf-ac0c-d433cdf1b15e)

예를 들어 페이지 참조 순서가 0, 1, 2, 0, 0, 1, 2, 3 이고 메모리 프레임 수가 3개라고 하자.

- 처음 0, 1, 2,를 순서대로 메모리에 로드한다.
- 0 페이지 Hit: 0의 참조 횟수가 2가 된다.
- 0 페이지 Hit: 0의 참조 횟수가 3이 된다.
- 1 페이지 Hit: 1의 참조 횟수가 2가 된다.
- 2 페이지 Hit: 2의 참조 횟수가 2가 된다.
- 3 페이지 요청: 가장 참조 횟수가 적은 1페이지를 3으로 교체한다.
    - 이떄 1과 2 페이지 모두 참조 횟수가 2회로 동일하게 가장 낮다. 처리 방식은 구현하기 나름이다.
    - FIFO, 무작위, 가장 최근 참조된 순서를 고려(LRU와 결합)
