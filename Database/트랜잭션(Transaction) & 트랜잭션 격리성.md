## **트랜잭션(Transaction)이란?**

**DBMS에서 일련의 연산을 논리적인 작업 단위로 묶어 처리하는 개념.** 여러 작업을 하나의 단위로 처리.

데이터베이스의 **무결성 유지**를 위함.

<br/>

\* **무결성** : 데이터의 정확성, 일관성, 유효성을 유지하는 것

<br/>

> **예시) 은행 시스템**  
> 계좌 A에서 계좌 B로 돈을 이체할 때, A의 잔고 감소와 B의 잔고 증가가 하나의 트랜잭션으로 처리되어야 한다.  
> 만약 하나라도 실패하면 전체 트랜잭션이 롤백되어야 한다.

<br/><br/><br/>

## **트랜잭션의 특성 (ACID)**

**Atomicty / All or nothing (원자성)**

-   트랜잭션의 연산은 모두 성공하거나 모두 실패해야한다.

**Consistency (일관성)**

-   트랜잭션이 수행 결과는 항상 일관되어야 한다.

**Isolation (고립성/독립성)**

-   트랜잭션이 수행되는 동안 다른 트랜잭션의 작업이 간섭받지 않아야 한다.

**Durability (지속성)**

-   트랜잭션이 성공적으로 완료된 경우, 그 결과는 영구적으로 반영되어야 한다.

<br/><br/><br/>

## **트랜잭션 연산**

**BEGIN TRANSACTION**

-   트랜잭션의 시작 선언.
-   이 시점부터 트랜잭션 연산 추적.

**READ/WRITE**

-   데이터베이스를 읽거나 쓰는 연산.

**COMMIT**

-   트랜잭션이 성공적으로 완료되었음을 선언.
-   모든 변경 사항을 데이터베이스에 영구적으로 반영.

**ROLLBACK**

-   트랜잭션 실패나 오류 발생을 선언.
-   모든 변경 사항을 취소하여 데이터베이스를 트랜잭션 시작 전 상태로 복구.

<br/><br/><br/>

## **트랜잭션의 상태**

<img width="594" alt="image" src="https://github.com/user-attachments/assets/d28fe7ad-5b14-4e1f-b7d5-216c02514e23">


**Active (활성 상태)**

-   트랜잭션이 시작되고 연산이 수행되고 있는 상태
-   아직 완료되지 않은 상태로, 중간 연산이 진행 중이다.

**Partially Committed (부분 완료 상태)**

-   트랜잭션의 마지막 연산이 실행된 상태
-   최종적으로 완료되기 직전의 상태로, 커밋(commit)이 이루어지기 전이다.

**Committed (완료 상태)**

-   트랜잭션이 성공적으로 완료되고, 데이터베이스에 변경 사항이 영구적으로 반영된 상태
-   트랜잭션의 모든 연산이 성공적으로 수행되어 데이터베이스의 일관성이 유지된 상태이다.

**Failed (실패 상태)**

-   트랜잭션 실행 중 오류가 발생하여 더 이상 수행할 수 없는 상태
-   트랜잭션이 실패하면 롤백(rollback)이 수행되어야 한다.

**Aborted (철회 상태)**

-   트랜잭션이 실패하여 롤백이 수행된 상태
-   트랜잭션의 모든 변경 사항이 취소되고 데이터베이스가 트랜잭션 시작 전 상태로 복구된다.

<br/><br/><br/>

## **회복 기법**

트랜잭션 실패나 시스템 장애가 발생했을 때 데이터베이스를 일관된 상태로 복구하는 기법.

<br/>

> **로그 기반 회복** : 트랜잭션의 모든 변경사항을 순차적으로 로그  
>   
> \- BEGIN: 트랜잭션이 시작됨을 기록.  
> \- UPDATE: 트랜잭션이 수행한 데이터의 변경 사항을 기록.  
> \- COMMIT: 트랜잭션이 성공적으로 완료됨을 기록.  
> \- ROLLBACK: 트랜잭션이 실패하여 롤백됨을 기록.

<br/>

**Undo Logging**:

-   트랜잭션이 실패했을 때 이전 상태로 복구
-   트랜잭션이 변경한 내용을 로그에 기록하고, 실패 시 로그를 역순으로 읽어 복구한다.

**Redo Logging**:

-   트랜잭션이 성공적으로 완료된 경우 변경 내용을 재적용하여 복구
-   커밋된 트랜잭션의 변경 내용을 로그에 기록하고, 시스템 장애 후 로그를 읽어 복구한다.

**Undo/Redo Logging**:

-   위의 두 가지 방법을 결합하여 트랜잭션의 상태에 따라 적절히 복구
-   트랜잭션이 커밋되지 않은 경우 Undo Logging을 사용하고, 커밋된 경우 Redo Logging을 사용한다.

<br/><br/><br/>

## **트랜잭션 격리성(Transaction Isolation)이란?**

각 트랜잭션이 다른 트랜잭션의 중간 상태를 볼 수 없도록 보장하는 성질을 의미. 

다양한 수준의 격리성이 제공되며, 트랜잭션 간 간섭을 얼마나 엄격하게 제어할지를 정의.

격리성이 높으면 데이터의 일관성을 더 잘 유지할 수 있음.

하지만, 성능 저하나 병행 실행에 제한이 있을 수 있음.

격리성 ⬆️ 일관성 ⬆️ 동시성 ⬇️

<br/><br/><br/>

## **트랜잭션 격리 수준**

**READ UNCOMMITTED (미완료 읽기 허용)**

-   가장 낮은 격리 수준. 트랜잭션이 커밋되지 않은 데이터를 읽을 수 있다.

**READ COMMITTED (커밋 읽기 허용)**

-   트랜잭션이 커밋된 데이터만 읽을 수 있다.

**REPEATABLE READ (반복 가능 읽기)**

-   트랜잭션이 시작된 후에 읽은 데이터는 다른 트랜잭션에 의해 변경될 수 없다.

**SERIALIZABLE (직렬화 가능)**

-   가장 높은 격리 수준으로, 트랜잭션이 직렬적으로 실행되는 것처럼 보이도록 보장한다.
-   성능 저하가 있을 수 있지만, 데이터의 일관성을 가장 잘 유지한다.

<br/><br/><br/>

## **트랜잭션 이상 현상**

동시에 여러 트랜잭션이 실행될 때 발생할 수 있는 문제들

**Dirty Read (더티 리드)**

-   커밋되지 않은 변경사항 읽어버리는 현상

<img width="594" alt="image" src="https://github.com/user-attachments/assets/b1ecc64c-49df-4a37-bd9b-daee54d05935">

트랜잭션1이 업데이트 이후 롤백을 할 수 있음에도 트랜잭션2는 업데이트 된 데이터를 읽음. 이후 롤백되어 데이터가 변경되면 데이터의 무결성을 해치게 됨.

<br/><br/>

**Non-Repeatable Read (반복되지 않는 읽기)**

-   같은 데이터에 두번 이상 접근하는데 그 값이 다른 현상.

<img width="594" alt="image" src="https://github.com/user-attachments/assets/aff8165d-9956-488a-b69a-67f7acd1a6e1">

트랜잭션 2가 같은 데이터를 두 번 읽을 때, 두 읽기 사이에 다른 트랜잭션 1이 데이터를 변경함.

<br/><br/>

**Phantom Read (팬텀 리드)**

-   같은 쿼리를 두 번 실행하는데 결과가 다른 현상.

<img width="594" alt="image" src="https://github.com/user-attachments/assets/bd1319bd-cc81-4454-98f8-a0b3150cd6d6">

트랜잭션1이 같은 쿼리를 두 번 실행할 때,두 쿼리 사이에 다른 트랜잭션2가 데이터를 추가하여 쿼리 결과가 달라짐


<br/><br/>

**격리 수준 별 발생할 수 있는 이상현상**

| **격리수준 \\ 이상현상** | **Dirty Read** | **Non-Repeatable Read** | **Phantom Read** |
| --- | --- | --- | --- |
| **READ UNCOMMITTED** | O | O | O |
| **READ COMMITTED** | X | O | O |
| **REPEATABLE READ** | X | X | O |
| **SERIALIZABLE** | X | X | X |
